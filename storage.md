## 存储结构
在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page）。一个页中可以存储多个行记录（Row），同时在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）。一个表空间包括了一个或多个段，一个段包括了一个或多个区，一个区包括了多个页，而一个页中可以有多行记录

区（Extent）是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64 * 16KB = 1MB

段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64 个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段

表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。在 InnoDB 中存在两种表空间的类型：共享表空间和独立表空间。如果是共享表空间就意味着多张表共用一个表空间。如果是独立表空间，就意味着每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间可以在不同的数据库之间进行迁移。可以通过下面的命令来查看 InnoDB 的表空间类型：
```sql
show variables like 'innodb_file_per_table';
```

如果结果为 ON，则表示每张表都会单独保存为一个 .ibd 文件


## 数据页
页（Page）如果按类型划分的话，常见的有数据页（保存 B+ 树节点）、系统页、Undo 页和事务数据页等。表页的大小限定了表行的最大长度，在 InnoDB 存储引擎中，默认页的大小是 16KB，可以通过下面的命令来进行查看：
```sql
show variables like '%innodb_page_size%';
```

数据页包括七个部分，分别是文件头（File Header 38Bytes）、页头（Page Header 56Bytes）、最大最小记录（Infimum + supremum 26Bytes）、用户记录（User Records）、空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Tailer 8Bytes）

通过文件头和文件尾校验的方式来确保页的传输是完整的。在文件头中有两个字段，分别是 FIL_PAGE_PREV 和 FIL_PAGE_NEXT，它们分别指向上一个数据页和下一个数据页

最小和最大记录、用户记录部分占了页结构的主要空间

空闲空间是个灵活的部分，当有新的记录插入时，会从空闲空间中进行分配用于存储新记录

页目录起到了记录的索引作用。记录是以单向链表的形式进行存储的，插入、删除非常方便，但是检索效率不高。因此在页目录中提供了二分查找的方式，用来提高记录的检索效率。


## B+ 树查询流程
在 B+ 树中，每个节点都是一个页，每次新建节点的时候，就会申请一个页空间。同一层上的节点之间，通过页的结构构成一个双向的链表（页文件头中的两个指针字段）。非叶子节点，包括了多个索引行，每个索引行里存储索引键和指向下一层页面的页面指针。最后是叶子节点，它存储了关键字和行记录，在节点内部（也就是页结构的内部）记录之间是一个单向的链表

通过 B+ 树的索引查询行记录，首先是从 B+ 树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot）采用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录

唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，查找时需要多几次判断下一条记录的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别


## 缓冲池
缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取

当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。缓冲池会采用一种叫做 checkpoint 的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。当缓冲池不够用时，需要释放掉一些不常用的页，就可以采用 checkpoint 的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉

```sql
show variables like 'innodb_buffer_pool_size'
```
```sql
set global innodb_buffer_pool_size = 134217728;
```

同时开启多个缓冲池
```sql
show variables like 'innodb_buffer_pool_instances';
```

innodb_buffer_pool_instances 默认情况下为 8。不过，我们首先需要将 innodb_buffer_pool_size 参数设置为大于等于 1GB，这时 innodb_buffer_pool_instances 才会大于 1

可以在 MySQL 的配置文件中对 innodb_buffer_pool_size 进行设置，大于等于 1GB，然后再针对 innodb_buffer_pool_instances 参数进行修改



SQL 查询成本
在执行完这条 SQL 语句之后，通过查看当前会话中的 last_query_cost 变量值来得到当前查询的成本。这个查询成本对应的是 SQL 语句所需要读取的页的数量

```sql
SELECT comment_id, product_id, comment_text, user_id FROM product_comment WHERE comment_id = 900001;
SELECT comment_id, product_id, comment_text, user_id FROM product_comment WHERE comment_id BETWEEN 900001 AND 900100;
```
```sql
SHOW STATUS LIKE 'last_query_cost';
```

第二个查询，页的数量可能会增多，但是查询的效率可能并没有明显的变化。这是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量（last_query_cost）增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间

