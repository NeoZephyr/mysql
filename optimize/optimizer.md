## 查询优化器
查询语句首先会经过分析器，进行语法分析和语义检查。语法分析检查 SQL 拼写和语法是否正确，语义检查是检查 SQL 中的访问对象是否存在。最终得到一棵语法分析树，然后经过查询优化器得到查询计划，最后交给执行器进行执行

查询优化器的目标是找到执行 SQL 查询的最佳执行计划，执行计划就是查询树，它由一系列物理操作符组成，这些操作符按照一定的运算关系组成查询的执行计划

在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段
逻辑查询优化通常采用的方式是对 SQL 语句进行等价变换，对查询进行重写，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等

逻辑查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划


## 基于规则的优化器
通过在优化器里面嵌入规则，来判断 SQL 查询符合的规则，并按照相应的规则来制定执行计划，同时采用启发式规则去掉明显不好的存取路径

## 基于代价的优化器
根据代价评估模型，计算每条可能的执行计划的代价，从中选择代价最小的作为执行计划

相比于 RBO 来说，CBO 对数据更敏感，因为它会利用数据表中的统计信息来做判断，针对不同的数据表，查询得到的执行计划可能是不同的，因此制定出来的执行计划也更符合数据表的实际情况

COST Model 是优化器用来统计各种步骤的代价模型，在 5.7.10 版本之后，MySQL 会引入两张数据表，里面规定了各种步骤预估的代价

```sql
SELECT * FROM mysql.server_cost;
```
server 层统计的代价：
1. disk_temptable_create_cost，表示临时表文件的创建代价，默认值为 20
2. disk_temptable_row_cost，表示临时表文件的行代价，默认值 0.5
3. key_compare_cost，表示键比较的代价。键比较的次数越多，这项的代价就越大，这是一个重要的指标，默认值 0.05
4. memory_temptable_create_cost，表示内存中临时表的创建代价，默认值 1
5. memory_temptable_row_cost，表示内存中临时表的行代价，默认值 0.1
6. row_evaluate_cost，统计符合条件的行代价，如果符合条件的行数越多，那么这一项的代价就越大，因此这是个重要的指标，默认值 0.1

```sql
SELECT * FROM mysql.engine_cost;
```
存储引擎层代价：
1. io_block_read_cost，从磁盘中读取一页数据的代价，默认是 1
2. memory_block_read_cost，从内存中读取一页数据的代价，默认是 0.25

我们可以根据实际情况去修改这些参数。因为随着硬件的提升，各种硬件的性能对比也可能发生变化，比如针对普通硬盘的情况，可以考虑适当增加 io_block_read_cost 的数值，这样就代表从磁盘上读取一页数据的成本变高了
```sql
UPDATE mysql.engine_cost SET cost_value = 2.0
WHERE cost_name = 'io_block_read_cost';
FLUSH OPTIMIZER_COSTS;
```


## 代价模型计算
简单的说，总的执行代价等于 I/O 代价 + CPU 代价
