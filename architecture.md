## Server 层
涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等

### 连接器
管理连接，权限验证

```sh
# 建立连接
mysql -h127.0.0.1 -P3306 -uroot -p123456
```

如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限，此后在这个连接里面的操作都依赖此时读取到的权限

可以通过以下命令查看数据库连接，如果长时间没有动作，连接器会自动断开。默认为 8 小时，由参数 `wait_timeout` 控制
```sh
show processlist;
```

在 mysql 执行过程中，临时使用的内存是管理在连接对象里面的，这些资源在连接断开时才释放。因此，如果连接长期不释放，累积下来会导致内存太大，被系统杀掉，导致 mysql 异常重启。在 5.7 及以后版本，在执行完一个大操作之后，可以通过执行 `mysql_reset_connection` 来重新初始化连接资源（不需要重连和重做权限验证），将连接恢复到刚刚创建完时的状态；也可以通过定期断开连接来解决该问题

### 查询缓存
mysql 接收到查询请求后，会先查询缓存。之前执行过的语句及其结果可能会以 `key-value` 的形式缓存在内存中，其中 `key` 是查询语句，`value` 是查询结果。实际情况下，查询缓存失效非常频繁，只要对一个表做更新操作，该表上面的查询缓存都会被清空。因此除非是类似于系统配置类的静态表，一般不使用查询缓存。将参数 `query_cache_type` 设置为 `DEMAND`，这样对默认的 SQL 语句都不使用查询缓存。如果要使用查询缓存，可以在语句中显示指定：
```sql
select SQL_CACHE * from sys_settings;
```

查看参数 `query_cache_type` 设置
```sql
show variables like "query_cache_type";
```

另外，查询缓存功能在 MYSQL8.0 取消了

### 分析器
如果没有命中缓存，就开始真正执行语句，对 SQL 语句进行词法分析与语法分析

### 优化器
优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联的时候，决定各个表的连接顺序，比如说：
```sql
# 可以先从表 t1 中取出 c=10 的记录的 id 值，再根据 id 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20
# 也可以先从表 t2 中取出 d=20 的记录的 id 值，再根据 id 值关联到表 t1，再判断 t1 里面 c 的值是否等于 10
select * from t1 join t2 using(id) where t1.c=10 and t2.d=20;
```

### 执行器
查询语句
```sql
select * from T where id = 10；
```
先判断是否具有表 `user` 的执行权限，如果有权限才能继续执行。如果 `id` 字段没有索引，执行流程如下：
1. 调用 innodb 引擎接口读取表的第一行，并判断 id 是否为 1，若不是则跳过，若是则将这行存在结果集中
2. 调用引擎接口获取下一行，重复相同逻辑直到最后一行
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端

如果 `id` 字段有索引，执行流程类似，第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，直到查询找出所有满足条件的记录

在数据库的慢查询日志中看到一个 rows_examined 字段，表示语句执行过程中扫描了多少行，这个值就是在执行器每次调用引擎获取数据数据行时累加的。但在某些情况下，执行器调用一次，在引擎内部扫描了多行，因此引擎扫描行数与 rows_examined 并不是完全相同的

更新语句
```sql
update T set name = "" where id = 10;
```
更新语句执行流程与查询语句执行流程大致类似，但有两点注意。一是更新语句会将对应表 T 上面的缓存结果都清空；二是更新过程涉及到两个重要的日志模块：`redo log` 与 `binlog`

查看 profiling 是否开启
```sql
select @@profiling;
```
打开 profiling
```sql
set profiling=1;
```
```sql
select * from T;
```
查看当前会话所产生的所有 profiles
```sql
show profiles;
```
获取上一次查询的执行时间
```sql
show profile;
```
查询指定的 Query ID
```sql
show profile for query 2;
```

查看 MySQL 的版本
```sql
select version();
```


## 存储引擎层
负责数据的存储和提取，支持 InnoDB、MyISAM、Memory 等多个存储引擎。存储引擎负责存储数据，提供读写接口

### MyISAM
1. 不支持事务
2. 支持表级锁
3. 存储表的总行数
4. 一个 MyISAM 表有三个文件：索引文件、表结构文件、数据文件
5. 采用非聚集索引：B+ 树的数据结构中存储的内容实际上是实际数据的地址值，也就是说它的索引和实际数据是分开的

### InnoDb
1. 支持事务
2. 支持行级锁
3. 不存储总行数
4. 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持 B+ 树结构，文件的大调整


## Innodb 逻辑存储结构
### 表空间
InnoDB 提供了两种表空间存储数据的方式，一种是共享表空间，一种是独占表空间

InnoDB 默认会将其所有的表数据存储在一个共享表空间中，即 ibdata1。可以通过设置 innodb_file_per_table 参数为 1 开启独占表空间模式。开启之后，每个表都有自己独立的表空间物理文件，所有的数据以及索引都会存储在该文件中，这样方便备份以及恢复数据

### 段
表空间是由各个段组成的，段一般分为数据段、索引段和回滚段等。索引段是 B+ 树的非叶子节点，数据段是 B+ 树的叶子节点。回滚段是回滚数据

### 区/页
区是表空间的单元结构，每个区的大小为 1MB。而页是组成区的最小单元，页也是 InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区

### 行
InnoDB 存储引擎是面向列的(row-oriented)，也就是说数据是按行进行存放的，每个页
存放的行记录也是有硬性定义的，最多允许存放 16KB/2-200 行，即 7992 行记录。
